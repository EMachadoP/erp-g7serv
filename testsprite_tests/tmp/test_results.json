[
  {
    "projectId": "90c839b3-6fd1-48c1-8f09-ef2492ea6f40",
    "testId": "35acc629-3c7d-4a8d-abb8-7dfa9e6d6d85",
    "userId": "e4883448-a031-7061-9194-a0d036678541",
    "title": "TC001-test_admin_login_access_control",
    "description": "Verify that the /admin/ endpoint restricts access to authorized users only and properly logs login attempts.",
    "code": "import requests\n\nBASE_URL = \"https://web-production-34bc.up.railway.app\"\nTIMEOUT = 30\n\ndef test_admin_login_access_control():\n    # Attempt unauthenticated GET request to /admin/\n    admin_url = f\"{BASE_URL}/admin/\"\n    try:\n        response = requests.get(admin_url, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to /admin/ failed: {e}\"\n\n    # We expect a redirect to login page (HTTP 302) or HTTP 200 login page but restricted\n    # Django admin usually redirects to /admin/login/ if not authenticated\n    # Accept either 200 or 302 but check if unauthenticated access does not show admin dashboard content\n    assert response.status_code in (200, 302), f\"Unexpected status code {response.status_code} for unauthenticated access\"\n\n    # If redirected, verify Location header points to login page\n    if response.status_code == 302:\n        location = response.headers.get(\"Location\", \"\")\n        assert location.endswith(\"/admin/login/?next=/admin/\") or \"/admin/login\" in location, \\\n            f\"Redirect location expected to be login page but was {location}\"\n    else:\n        # 200 might be login page HTML, check that it contains login form but not admin content\n        content = response.text.lower()\n        assert (\"login\" in content or \"username\" in content) and \"csrfmiddlewaretoken\" in content, \\\n            \"Unauthenticated access to /admin/ should show login page\"\n\n    # Attempt authorized access by logging in and then accessing /admin/\n    # Since no credentials are given, try to authenticate with invalid and valid attempts if possible\n    # This test only verifies access restriction and logging: simulate login attempt with invalid credentials\n    login_url = f\"{BASE_URL}/admin/login/\"\n    login_data = {\n        \"username\": \"invalid_user\",\n        \"password\": \"wrong_password\",\n        \"csrfmiddlewaretoken\": None  # Will fetch from login page\n    }\n\n    session = requests.Session()\n\n    # Fetch login page first to get csrf token\n    try:\n        login_page = session.get(login_url, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to /admin/login/ failed: {e}\"\n\n    assert login_page.status_code == 200, f\"Expected 200 OK for login page, got {login_page.status_code}\"\n\n    # Extract csrfmiddlewaretoken from login page HTML\n    import re\n    match = re.search(r'name=\"csrfmiddlewaretoken\" value=\"([^\"]+)\"', login_page.text)\n    assert match, \"CSRF token not found on login page\"\n    csrf_token = match.group(1)\n    login_data[\"csrfmiddlewaretoken\"] = csrf_token\n\n    headers = {\n        \"Referer\": login_url\n    }\n\n    try:\n        post_response = session.post(login_url, data=login_data, headers=headers, timeout=TIMEOUT, allow_redirects=False)\n    except requests.RequestException as e:\n        assert False, f\"Login POST request failed: {e}\"\n\n    # Validate response implies failed login (should be 200 with form showing errors or redirect to login again)\n    assert post_response.status_code in (200, 302), f\"Unexpected status code after login attempt: {post_response.status_code}\"\n\n    if post_response.status_code == 302:\n        # Redirect back to login page (login failure)\n        location = post_response.headers.get(\"Location\", \"\")\n        assert \"/admin/login/\" in location, f\"Expected redirect to login page after failed login but got {location}\"\n    else:\n        # Response page after failed login should contain error message\n        assert \"please enter the correct username and password\" in post_response.text.lower() or \\\n               \"error\" in post_response.text.lower(), \"Expected login error message after failed login\"\n\n    # Confirm that after failed login, access to /admin/ is still restricted\n    try:\n        admin_resp_after_login = session.get(admin_url, timeout=TIMEOUT, allow_redirects=False)\n    except requests.RequestException as e:\n        assert False, f\"Request to /admin/ after login attempt failed: {e}\"\n    assert admin_resp_after_login.status_code in (302, 200), \\\n        f\"Expected 302 redirect or 200 on /admin/ access after failed login, got {admin_resp_after_login.status_code}\"\n\n    if admin_resp_after_login.status_code == 302:\n        loc = admin_resp_after_login.headers.get(\"Location\", \"\")\n        assert loc.endswith(\"/admin/login/?next=/admin/\") or \"/admin/login\" in loc, \\\n            f\"Access to /admin/ after failed login must redirect to login page, got {loc}\"\n    else:\n        # 200 may be login page again showing form\n        content2 = admin_resp_after_login.text.lower()\n        assert (\"login\" in content2 or \"username\" in content2) and \"csrfmiddlewaretoken\" in content2, \\\n            \"Access to /admin/ after failed login should show login page\"\n\ntest_admin_login_access_control()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-01T12:42:22.897Z",
    "modified": "2026-02-01T12:42:53.897Z"
  },
  {
    "projectId": "90c839b3-6fd1-48c1-8f09-ef2492ea6f40",
    "testId": "0a0fcc71-ef36-493f-a900-971aab7f0199",
    "userId": "e4883448-a031-7061-9194-a0d036678541",
    "title": "TC002-test_crm_dashboard_access_and_data_integrity",
    "description": "Verify that the /comercial/ endpoint provides access to the CRM dashboard and correctly displays client, quotation, and contract data according to business rules.",
    "code": "import requests\n\nBASE_URL = \"https://web-production-34bc.up.railway.app\"\nTIMEOUT = 30\n\n\ndef test_crm_dashboard_access_and_data_integrity():\n    headers = {\n        \"Accept\": \"application/json\",\n    }\n\n    # Test /comercial/ endpoint (CRM Dashboard)\n    resp_comercial = requests.get(f\"{BASE_URL}/comercial/\", headers=headers, timeout=TIMEOUT)\n    assert resp_comercial.status_code == 200, f\"/comercial/ status code expected 200 but got {resp_comercial.status_code}\"\n    comercial_json = resp_comercial.json()\n    # Check keys related to clients, quotations, contracts expected to be in the response\n    assert any(\n        key in comercial_json for key in (\"clients\", \"quotations\", \"contracts\")\n    ), \"CRM Dashboard response should contain client, quotation, or contract data keys\"\n\n    # Test /operacional/ endpoint (Field Service Dashboard)\n    resp_operacional = requests.get(f\"{BASE_URL}/operacional/\", headers=headers, timeout=TIMEOUT)\n    assert resp_operacional.status_code == 200, f\"/operacional/ status code expected 200 but got {resp_operacional.status_code}\"\n    operacional_json = resp_operacional.json()\n    # Validate response contains expected operational data keys\n    assert isinstance(operacional_json, dict), \"/operacional/ response should be a JSON object\"\n\n    # Test /ai/processar/ endpoint (AI message triage) - POST with a sample payload\n    payload = {\"message\": \"Status of client contract #1234?\"}\n    resp_ai = requests.post(f\"{BASE_URL}/ai/processar/\", headers={**headers, \"Content-Type\": \"application/json\"},\n                            json=payload, timeout=TIMEOUT)\n    assert resp_ai.status_code == 200, f\"/ai/processar/ POST status 200 expected but got {resp_ai.status_code}\"\n    ai_resp_json = resp_ai.json()\n    # Validate AI response contains a reply or processing outcome\n    assert (\n        \"response\" in ai_resp_json or \"result\" in ai_resp_json\n    ), \"/ai/processar/ response should contain 'response' or 'result' key\"\n\n    # Test /financeiro/ endpoint (Finance Dashboard) - Expecting redirect (status 3xx)\n    resp_financeiro = requests.get(f\"{BASE_URL}/financeiro/\", headers=headers, timeout=TIMEOUT, allow_redirects=False)\n    assert resp_financeiro.status_code in (301, 302, 303, 307, 308), f\"/financeiro/ expected redirect status but got {resp_financeiro.status_code}\"\n    location = resp_financeiro.headers.get(\"Location\")\n    assert location, \"/financeiro/ redirect response should contain 'Location' header\"\n\n\ntest_crm_dashboard_access_and_data_integrity()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 46, in <module>\n  File \"<string>\", line 14, in test_crm_dashboard_access_and_data_integrity\nAssertionError: /comercial/ status code expected 200 but got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-01T12:42:22.903Z",
    "modified": "2026-02-01T12:43:01.676Z"
  },
  {
    "projectId": "90c839b3-6fd1-48c1-8f09-ef2492ea6f40",
    "testId": "5a3dcea5-7a37-464b-9413-b485a1f24944",
    "userId": "e4883448-a031-7061-9194-a0d036678541",
    "title": "TC003-test_operational_dashboard_and_work_order_management",
    "description": "Verify that the /operacional/ endpoint provides access to the Field Service dashboard and supports work order state transitions, geolocation recording, and checklist validation during check-in and check-out.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"https://web-production-34bc.up.railway.app\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\ndef test_operational_dashboard_and_work_order_management():\n    session = requests.Session()\n    session.headers.update(HEADERS)\n\n    # 1. Verify access to /operacional/ dashboard (GET)\n    resp_dashboard = session.get(f\"{BASE_URL}/operacional/\", timeout=TIMEOUT)\n    assert resp_dashboard.status_code == 200, f\"Expected 200 OK for /operacional/, got {resp_dashboard.status_code}\"\n\n    # 2. Create a client under /comercial/clientes/ to link OS (POST)\n    client_payload = {\n        \"name\": f\"Test Client {uuid.uuid4()}\",\n        \"type\": \"individual\",\n        \"document\": \"12345678900\",\n        \"email\": \"testclient@example.com\",\n        \"phone\": \"+5511999999999\",\n        \"address\": \"123 Test St.\"\n    }\n    resp_client = session.post(f\"{BASE_URL}/comercial/clientes/\", json=client_payload, timeout=TIMEOUT)\n    assert resp_client.status_code == 201, f\"Expected 201 Created for /comercial/clientes/, got {resp_client.status_code}\"\n    client_id = resp_client.json().get(\"id\")\n    assert client_id is not None, \"Client creation response missing id\"\n\n    try:\n        # 3. Create a work order (OS) linked to client (POST)\n        os_payload = {\n            \"client_id\": client_id,\n            \"description\": \"Test Work Order\",\n            \"status\": \"pending\"  # initial state as per core goals\n        }\n        resp_os_create = session.post(f\"{BASE_URL}/operacional/os/\", json=os_payload, timeout=TIMEOUT)\n        assert resp_os_create.status_code == 201, f\"Expected 201 Created for /operacional/os/, got {resp_os_create.status_code}\"\n        os_data = resp_os_create.json()\n        os_id = os_data.get(\"id\")\n        assert os_id is not None, \"Work order creation response missing id\"\n        assert os_data.get(\"status\") == \"pending\", f\"Expected work order initial status 'pending', got {os_data.get('status')}\"\n\n        # 4. Transition state: pending -> in_progress (PUT)\n        update_state_payload = {\"status\": \"in_progress\"}\n        resp_update_state = session.put(f\"{BASE_URL}/operacional/os/{os_id}/\", json=update_state_payload, timeout=TIMEOUT)\n        assert resp_update_state.status_code == 200, f\"Expected 200 OK updating OS status, got {resp_update_state.status_code}\"\n        updated_os = resp_update_state.json()\n        assert updated_os.get(\"status\") == \"in_progress\", f\"Expected OS status 'in_progress', got {updated_os.get('status')}\"\n\n        # 5. Record geolocation on check-in (PATCH)\n        geolocation_checkin = {\n            \"check_in_location\": {\n                \"lat\": -23.55052,\n                \"lng\": -46.633308\n            },\n            \"check_in_time\": \"2026-01-31T10:00:00Z\"\n        }\n        resp_checkin = session.patch(f\"{BASE_URL}/operacional/os/{os_id}/\", json=geolocation_checkin, timeout=TIMEOUT)\n        assert resp_checkin.status_code == 200, f\"Expected 200 OK for geolocation check-in, got {resp_checkin.status_code}\"\n        os_after_checkin = resp_checkin.json()\n        assert \"check_in_location\" in os_after_checkin, \"check_in_location missing after check-in update\"\n        assert os_after_checkin.get(\"check_in_location\") == geolocation_checkin[\"check_in_location\"], \"check_in_location data mismatch\"\n\n        # 6. Validate checklist on check-in (PATCH)\n        checklist_checkin = {\n            \"checklist\": {\n                \"safety_gear\": True,\n                \"equipment_checked\": True,\n                \"client_informed\": True\n            }\n        }\n        resp_checklist_in = session.patch(f\"{BASE_URL}/operacional/os/{os_id}/\", json=checklist_checkin, timeout=TIMEOUT)\n        assert resp_checklist_in.status_code == 200, f\"Expected 200 OK for checklist update on check-in, got {resp_checklist_in.status_code}\"\n        os_after_checklist_in = resp_checklist_in.json()\n        assert os_after_checklist_in.get(\"checklist\") == checklist_checkin[\"checklist\"], \"Checklist data mismatch on check-in\"\n\n        # 7. Transition state: in_progress -> completed (PUT)\n        resp_update_state_done = session.put(f\"{BASE_URL}/operacional/os/{os_id}/\", json={\"status\": \"completed\"}, timeout=TIMEOUT)\n        assert resp_update_state_done.status_code == 200, f\"Expected 200 OK updating OS status to completed, got {resp_update_state_done.status_code}\"\n        os_done = resp_update_state_done.json()\n        assert os_done.get(\"status\") == \"completed\", f\"Expected OS status 'completed', got {os_done.get('status')}\"\n\n        # 8. Record geolocation on check-out (PATCH)\n        geolocation_checkout = {\n            \"check_out_location\": {\n                \"lat\": -23.55100,\n                \"lng\": -46.634000\n            },\n            \"check_out_time\": \"2026-01-31T12:00:00Z\"\n        }\n        resp_checkout = session.patch(f\"{BASE_URL}/operacional/os/{os_id}/\", json=geolocation_checkout, timeout=TIMEOUT)\n        assert resp_checkout.status_code == 200, f\"Expected 200 OK for geolocation check-out, got {resp_checkout.status_code}\"\n        os_after_checkout = resp_checkout.json()\n        assert \"check_out_location\" in os_after_checkout, \"check_out_location missing after check-out update\"\n        assert os_after_checkout.get(\"check_out_location\") == geolocation_checkout[\"check_out_location\"], \"check_out_location data mismatch\"\n\n        # 9. Validate checklist on check-out (PATCH)\n        checklist_checkout = {\n            \"checklist\": {\n                \"work_reported\": True,\n                \"client_signature\": True,\n                \"equipment_cleaned\": True\n            }\n        }\n        resp_checklist_out = session.patch(f\"{BASE_URL}/operacional/os/{os_id}/\", json=checklist_checkout, timeout=TIMEOUT)\n        assert resp_checklist_out.status_code == 200, f\"Expected 200 OK for checklist update on check-out, got {resp_checklist_out.status_code}\"\n        os_after_checklist_out = resp_checklist_out.json()\n        assert os_after_checklist_out.get(\"checklist\") == checklist_checkout[\"checklist\"], \"Checklist data mismatch on check-out\"\n\n    finally:\n        # Cleanup: delete created work order and client resources\n        if 'os_id' in locals():\n            session.delete(f\"{BASE_URL}/operacional/os/{os_id}/\", timeout=TIMEOUT)\n        if client_id:\n            session.delete(f\"{BASE_URL}/comercial/clientes/{client_id}/\", timeout=TIMEOUT)\n\n    # 10. Verify redirects for /comercial/, /financeiro/, and /ai/processar/\n\n    # /comercial/ dashboard GET\n    resp_comercial = session.get(f\"{BASE_URL}/comercial/\", allow_redirects=False, timeout=TIMEOUT)\n    assert resp_comercial.status_code in (200, 302), f\"Unexpected status for /comercial/: {resp_comercial.status_code}\"\n    if resp_comercial.status_code == 302:\n        assert \"location\" in resp_comercial.headers, \"Redirect missing Location header for /comercial/\"\n\n    # /financeiro/ dashboard GET\n    resp_financeiro = session.get(f\"{BASE_URL}/financeiro/\", allow_redirects=False, timeout=TIMEOUT)\n    assert resp_financeiro.status_code in (200, 302), f\"Unexpected status for /financeiro/: {resp_financeiro.status_code}\"\n    if resp_financeiro.status_code == 302:\n        assert \"location\" in resp_financeiro.headers, \"Redirect missing Location header for /financeiro/\"\n\n    # /ai/processar/ POST: test minimal valid payload and check for valid response\n    ai_payload = {\"message\": \"Status update request\"}\n    resp_ai = session.post(f\"{BASE_URL}/ai/processar/\", json=ai_payload, timeout=TIMEOUT)\n    assert resp_ai.status_code == 200, f\"Expected 200 OK for AI processing, got {resp_ai.status_code}\"\n    ai_response_json = resp_ai.json()\n    assert isinstance(ai_response_json, dict), \"AI response is not a JSON object\"\n    assert \"response\" in ai_response_json or \"status\" in ai_response_json, \"AI response missing expected keys\"\n\n\ntest_operational_dashboard_and_work_order_management()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 143, in <module>\n  File \"<string>\", line 16, in test_operational_dashboard_and_work_order_management\nAssertionError: Expected 200 OK for /operacional/, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-01T12:42:22.910Z",
    "modified": "2026-02-01T12:43:47.381Z"
  },
  {
    "projectId": "90c839b3-6fd1-48c1-8f09-ef2492ea6f40",
    "testId": "8b1d9f38-4452-4cf5-8128-565881ba6be7",
    "userId": "e4883448-a031-7061-9194-a0d036678541",
    "title": "TC004-test_finance_dashboard_and_transaction_reconciliation",
    "description": "Verify that the /financeiro/ endpoint provides access to the Finance dashboard and accurately records and reconciles financial transactions including cash flow, accounts payable/receivable, and bank statements.",
    "code": "import requests\n\nBASE_URL = \"https://web-production-34bc.up.railway.app\"\nTIMEOUT = 30\n\n\ndef test_finance_dashboard_and_transaction_reconciliation():\n    session = requests.Session()\n    session.headers.update({\n        \"Accept\": \"application/json\",\n        \"User-Agent\": \"ERP-G7Serv-TestClient/1.0\"\n    })\n\n    # Verify CRM dashboard accessible and functional (/comercial/)\n    resp_comercial = session.get(f\"{BASE_URL}/comercial/\", timeout=TIMEOUT, allow_redirects=True)\n    assert resp_comercial.status_code == 200, f\"/comercial/ expected 200 but got {resp_comercial.status_code}\"\n    assert \"application/json\" in resp_comercial.headers.get(\"Content-Type\", \"\"), \"/comercial/ did not return JSON\"\n    comercial_json = resp_comercial.json()\n    # Basic structural checks (assuming dashboard JSON has keys like clients, quotations, contracts)\n    assert isinstance(comercial_json, dict), \"/comercial/ response not dict\"\n    assert any(key in comercial_json for key in [\"clients\", \"quotations\", \"contracts\"]), \"/comercial/ missing expected keys\"\n\n    # Verify Operational dashboard accessible and functional (/operacional/)\n    resp_operacional = session.get(f\"{BASE_URL}/operacional/\", timeout=TIMEOUT, allow_redirects=True)\n    assert resp_operacional.status_code == 200, f\"/operacional/ expected 200 but got {resp_operacional.status_code}\"\n    assert \"application/json\" in resp_operacional.headers.get(\"Content-Type\", \"\"), \"/operacional/ did not return JSON\"\n    operacional_json = resp_operacional.json()\n    # Expect keys related to work orders or statuses\n    assert isinstance(operacional_json, dict), \"/operacional/ response not dict\"\n    assert any(key in operacional_json for key in [\"work_orders\", \"statuses\"]), \"/operacional/ missing expected keys\"\n\n    # Verify AI message processing endpoint (/ai/processar/)\n    ai_payload = {\"message\": \"Check finance report status\", \"query_type\": \"status_inquiry\"}\n    resp_ai = session.post(f\"{BASE_URL}/ai/processar/\", json=ai_payload, timeout=TIMEOUT)\n    assert resp_ai.status_code == 200, f\"/ai/processar/ POST expected 200 but got {resp_ai.status_code}\"\n    resp_ai_json = resp_ai.json()\n    assert isinstance(resp_ai_json, dict), \"/ai/processar/ response not dict\"\n    assert \"response\" in resp_ai_json or \"result\" in resp_ai_json, \"/ai/processar/ missing expected keys\"\n\n    # Verify Finance dashboard accessible and functional (/financeiro/) - redirect expected\n    resp_financeiro = session.get(f\"{BASE_URL}/financeiro/\", timeout=TIMEOUT, allow_redirects=True)\n    # It can redirect; final status code expected 200\n    assert resp_financeiro.status_code == 200, f\"/financeiro/ expected 200 but got {resp_financeiro.status_code}\"\n    # Check JSON response with finance-related keys\n    assert \"application/json\" in resp_financeiro.headers.get(\"Content-Type\", \"\"), \"/financeiro/ did not return JSON\"\n    financeiro_json = resp_financeiro.json()\n    assert isinstance(financeiro_json, dict), \"/financeiro/ response not dict\"\n    expected_finance_keys = [\"cash_flow\", \"accounts_payable\", \"accounts_receivable\", \"bank_statements\"]\n    assert any(key in financeiro_json for key in expected_finance_keys), \"/financeiro/ missing finance keys\"\n\n    # Additional checks for reconciliation consistency if data present\n    cash_flow = financeiro_json.get(\"cash_flow\", {})\n    accounts_payable = financeiro_json.get(\"accounts_payable\", {})\n    accounts_receivable = financeiro_json.get(\"accounts_receivable\", {})\n    bank_statements = financeiro_json.get(\"bank_statements\", {})\n\n    # Basic type checks\n    assert isinstance(cash_flow, dict) or isinstance(cash_flow, list), \"cash_flow should be dict or list\"\n    assert isinstance(accounts_payable, dict) or isinstance(accounts_payable, list), \"accounts_payable should be dict or list\"\n    assert isinstance(accounts_receivable, dict) or isinstance(accounts_receivable, list), \"accounts_receivable should be dict or list\"\n    assert isinstance(bank_statements, dict) or isinstance(bank_statements, list), \"bank_statements should be dict or list\"\n\n    # If numeric totals available, verify that cash flow roughly equals payables + receivables reconciled with bank statements\n    # This part is heuristic due to lack of schema specifics\n    def sum_amounts(items):\n        if isinstance(items, dict):\n            items = items.values()\n        total = 0\n        for entry in items:\n            if isinstance(entry, dict):\n                amount = entry.get(\"amount\") or entry.get(\"value\") or 0\n            else:\n                amount = 0\n            try:\n                total += float(amount)\n            except (ValueError, TypeError):\n                continue\n        return total\n\n    total_payable = sum_amounts(accounts_payable)\n    total_receivable = sum_amounts(accounts_receivable)\n    total_bank = sum_amounts(bank_statements)\n    total_cash_flow = sum_amounts(cash_flow)\n\n    # Rough consistency checks (amounts can be zero or missing)\n    assert abs(total_cash_flow - (total_receivable - total_payable)) < 1e-2 or total_cash_flow == 0, \\\n        \"cash_flow total inconsistent with receivables minus payables\"\n    # Bank statements should be roughly consistent with cash flow\n    assert abs(total_bank - total_cash_flow) < 1e-2 or total_bank == 0, \"bank_statements total inconsistent with cash_flow\"\n\n    session.close()\n\n\ntest_finance_dashboard_and_transaction_reconciliation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 94, in <module>\n  File \"<string>\", line 16, in test_finance_dashboard_and_transaction_reconciliation\nAssertionError: /comercial/ expected 200 but got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-01T12:42:22.916Z",
    "modified": "2026-02-01T12:43:02.233Z"
  },
  {
    "projectId": "90c839b3-6fd1-48c1-8f09-ef2492ea6f40",
    "testId": "5ff23265-c679-46d7-a377-10709daa64ac",
    "userId": "e4883448-a031-7061-9194-a0d036678541",
    "title": "TC005-test_ai_processar_endpoint_message_triage",
    "description": "Verify that the /ai/processar/ POST endpoint correctly processes AI message triage and status queries, returning valid responses and routing messages appropriately based on AI processing.",
    "code": "import requests\n\nBASE_URL = \"https://web-production-34bc.up.railway.app\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef test_ai_processar_endpoint_message_triage():\n    url = f\"{BASE_URL}/ai/processar/\"\n    payloads = [\n        # Sample message triage input\n        {\"message\": \"Request status update for order #12345\"},\n        # Sample AI status query\n        {\"message\": \"What is the current status of my service order?\"},\n        # Sample message expecting routing response\n        {\"message\": \"Please route this message to the finance department.\"},\n    ]\n    for payload in payloads:\n        try:\n            response = requests.post(url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n        except requests.RequestException as e:\n            assert False, f\"Request to /ai/processar/ failed: {e}\"\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n        try:\n            resp_json = response.json()\n        except ValueError:\n            assert False, \"Response is not valid JSON\"\n        assert \"result\" in resp_json or \"status\" in resp_json or \"route\" in resp_json, \\\n            \"Response JSON must contain 'result', 'status', or 'route' key\"\n        # Validate that the response content is a non-empty string/value\n        if \"result\" in resp_json:\n            assert isinstance(resp_json[\"result\"], str) and resp_json[\"result\"].strip() != \"\", \"Invalid 'result' content\"\n        if \"status\" in resp_json:\n            assert isinstance(resp_json[\"status\"], str) and resp_json[\"status\"].strip() != \"\", \"Invalid 'status' value\"\n        if \"route\" in resp_json:\n            assert isinstance(resp_json[\"route\"], str) and resp_json[\"route\"].strip() != \"\", \"Invalid 'route' content\"\n\ntest_ai_processar_endpoint_message_triage()\n",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-01T12:42:22.921Z",
    "modified": "2026-02-01T12:43:13.048Z"
  }
]
